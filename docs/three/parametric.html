<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Parametric Surface</title>
  <link rel="stylesheet" href="../assets/style.css" />
  <style>body{background:#0b1020}</style>
</head>
<body>
  <div class="container">
    <div class="header"><div class="logo"></div><div><div class="title">Parametric Surface</div><div class="subtitle">z = sin(x + t) * cos(y + t)</div></div></div>
    <div class="hero" style="height:460px"><div class="canvas" id="app"></div></div>
    <a class="button" href="index.html">‚Üê Back</a>
  </div>
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.161.0/build/three.module.js';
    import {OrbitControls} from 'https://unpkg.com/three@0.161.0/examples/jsm/controls/OrbitControls.js?module';

    const el = document.getElementById('app');
    const renderer = new THREE.WebGLRenderer({antialias:true});
    el.appendChild(renderer.domElement);
    renderer.setPixelRatio(devicePixelRatio);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b1020);

    const camera = new THREE.PerspectiveCamera(55, 1, 0.1, 1000);
    camera.position.set(0, 10, 18);
    const controls = new OrbitControls(camera, renderer.domElement);

    scene.add(new THREE.AmbientLight(0x88aaff, 0.6));
    const dl = new THREE.DirectionalLight(0xffffff, 0.8); dl.position.set(5,10,7); scene.add(dl);

    const size = 64;
    const geom = new THREE.PlaneGeometry(20, 20, size, size);
    const mat = new THREE.MeshStandardMaterial({color:0x06b6d4, wireframe:true});
    const mesh = new THREE.Mesh(geom, mat);
    mesh.rotation.x = -Math.PI/2; scene.add(mesh);

    function resize(){
      const w = el.clientWidth, h = el.clientHeight; renderer.setSize(w,h); camera.aspect = w/h; camera.updateProjectionMatrix();
    } window.addEventListener('resize', resize); resize();

    function loop(t){
      const time = t*0.001;
      const pos = geom.attributes.position;
      for(let i=0;i<pos.count;i++){
        const x = (i % (size+1)) / size * Math.PI*4;
        const y = Math.floor(i / (size+1)) / size * Math.PI*4;
        const z = Math.sin(x + time) * Math.cos(y + time) * 1.2;
        pos.setZ(i, z);
      }
      pos.needsUpdate = true; geom.computeVertexNormals();
      controls.update(); renderer.render(scene, camera); requestAnimationFrame(loop);
    } requestAnimationFrame(loop);
  </script>
</body>
</html>